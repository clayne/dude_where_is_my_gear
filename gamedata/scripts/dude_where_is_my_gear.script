--[[
Dude where's my gear!? is inspired by EFT, where you lose all your gear when you die.
The idea is to put together a hideout with some extra weapons and gear,
still you'll have the opportunity of getting some of your gear back if you return (and survive) to the place where you died.
You'll lose a % of money and also equipped items will lose condition when you drop them.
--]] local max_money_percentage
local max_money_to_drop_percentage
local max_condition_lose
local min_condition_lose
local enable_time_forward
local full_heal_chance
local full_satiety_chance
local meal_chance
local keep_equipped_guns_ammo_chance
local lose_item_condition
local keep_equipped_guns_chance
local keep_equipped_outfit_chance
local chance_of_losing_items
local always_wake_up_daytime
local campfire_save
local remove_previous_stash
local use_kill_type_mod
local use_rank_mod
local actor_rep
local actor_rank
local sleep = {
    level = false,
    position = false,
    level_vert = false,
    game_vert = false,
    dead = false,
    stash_created = false,
    sleep_created = false,
    last_death_time = 0,
    stash_save = {},
    dropped_stashes = {},
    last_dropped_item_list = {},
    last_lost_item_list = {}
}
local currently_respawning = nil
local last_death_time = 0
local respawn_done = false
local global_healing = 1
local global_satiety = 1
local global_power = 1
local invulnerability = false
local options_vol = 1
local death_last_attacks = {}
local last_attack_time = 0
local rep_lvls = {"terrible", "really_bad", "very_bad", "bad", "neutral", "good", "very_good", "really_good",
                  "excellent"}
local ranks_mods = {
    ["novice"] = 1.8,
    ["trainee"] = 1.65,
    ["experienced"] = 1.45,
    ["professional"] = 1.35,
    ["veteran"] = 1.1,
    ["expert"] = 0.95,
    ["master"] = 0.85,
    ["legend"] = 0.75
}

-- Utils
local function add_hit_record(shit_type)
    last_attack_time = time_global()
    table.insert(death_last_attacks, shit_type)
    if #death_last_attacks > 25 then
        table.remove(death_last_attacks, 1)
    end
end

local function check_attack_history_expiration()
    if last_attack_time + 90000 < time_global() then
        death_last_attacks = {}
        print_dbg("ATTACK HISTORY CLEARED")
    end
end

local function count_death_hit_by_type(hits)
    local hit_counts = {
        [0] = 0,
        [1] = 0,
        [2] = 0,
        [3] = 0,
        [4] = 0,
        [5] = 0,
        [6] = 0,
        [7] = 0,
        [8] = 0,
        [9] = 0,
        [10] = 0
    }
    -- iterate over the hits array and count the hit types
    for _, hit_type in ipairs(hits) do
        if hit_counts[hit_type] ~= nil then
            hit_counts[hit_type] = hit_counts[hit_type] + 1
        end
    end
    return hit_counts
end

-- Thanks ChatGPT
local function getTop3Hits(counts)
    -- Create a new table to store the sorted counts
    local sortedCounts = {}

    -- Iterate over the key-value pairs in the counts table and add them to the sortedCounts table
    for key, value in pairs(counts) do
        table.insert(sortedCounts, {
            key = key,
            count = value
        })
    end

    -- Sort the sortedCounts table by count in descending order
    table.sort(sortedCounts, function(a, b)
        return a.count > b.count
    end)

    -- Create a new table to store the top 3 hits
    local top3Hits = {}

    -- Add the top 3 counts to the top3Hits table
    for i = 1, 3 do
        if sortedCounts[i] ~= nil then
            table.insert(top3Hits, sortedCounts[i])
        end
    end

    -- Return the top3Hits table
    return top3Hits
end

local function define_rank_modifier(actor_rank)
    local rank_modifier = 1
    print_dbg("actor_rank: " .. actor_rank)
    if ranks_mods[actor_rank] ~= nil then
        rank_modifier = ranks_mods[actor_rank]
        print_dbg("rank_modifier: " .. rank_modifier)
    end
    return rank_modifier
end

local HitTypeID = {
    [0] = "Burn",
    [1] = "Shock",
    [2] = "ChemicalBurn",
    [3] = "Radiation",
    [4] = "Telepatic",
    [5] = "Wound",
    [6] = "FireWound",
    [7] = "Strike",
    [8] = "Explosion",
    [9] = "Wound_2",
    [10] = "LightBurn"
}

local function determine_main_cause_of_death(hits)
    local hit_counts = count_death_hit_by_type(hits)
    local top3_hits = getTop3Hits(hit_counts)
    local top_cause = top3_hits[1].key
    local main_cause_of_death = "unknown"
    if top_cause == 6 or top_cause == 9 then
        main_cause_of_death = "gun"
    elseif top_cause == 0 or top_cause == 1 or top_cause == 2 then
        main_cause_of_death = "elemental"
    elseif top_cause == 3 then
        main_cause_of_death = "radiation"
    elseif top_cause == 4 then
        main_cause_of_death = "telepatic"
    elseif top_cause == 5 or top_cause == 7 then
        main_cause_of_death = "beast"
    elseif top_cause == 8 then
        main_cause_of_death = "explosion"
    end

    return main_cause_of_death
end

local function removeValueFromArray(array, valueToRemove)
    local newArray = {}
    for i, v in ipairs(array) do
        if v ~= valueToRemove then
            table.insert(newArray, v)
        end
    end
    return newArray
end

local function add_to_dropped_item_list(item, status, stash_id)
    sleep = alife_storage_manager.get_state().dude_where_is_my_gear or sleep
    if sleep.dropped_stashes[stash_id] == nil then
        sleep.dropped_stashes[stash_id] = {
            last_dropped_item_list = {},
            last_lost_item_list = {}
        }
    end
    local item_name = ui_item.get_sec_name(item:section()) or 'unknown'
    local drop_stash = sleep.dropped_stashes[stash_id]
    if status == "d" then
        print_dbg("Dropped item: " .. item_name)
        if drop_stash.last_dropped_item_list[item_name] == nil then
            drop_stash.last_dropped_item_list[item_name] = 1
        else
            drop_stash.last_dropped_item_list[item_name] = drop_stash.last_dropped_item_list[item_name] + 1
        end
    elseif status == "l" then
        print_dbg("Lost item: " .. item_name)
        if drop_stash.last_lost_item_list[item_name] == nil then
            drop_stash.last_lost_item_list[item_name] = 1
        else
            drop_stash.last_lost_item_list[item_name] = drop_stash.last_lost_item_list[item_name] + 1
        end
    end
    alife_storage_manager.get_state().dude_where_is_my_gear = sleep
end

local function create_report_msg_string(list_lost_only, stash_id)
    list_lost_only = list_lost_only or false
    sleep = alife_storage_manager.get_state().dude_where_is_my_gear or sleep
    local stash_items = sleep.dropped_stashes[stash_id] or nil
    local msg = ""
    for i, v in ipairs(sleep.dropped_stashes) do
        print_dbg("stash_items: %s %s" .. i .. " " .. v)
    end
    if not list_lost_only and stash_items then
        for item_name, count in pairs(stash_items.last_dropped_item_list) do
            msg = msg .. "- " .. item_name .. " x" .. count .. " stash_id " .. stash_id .. " \\n"
            -- print_dbg("Dropped item: " .. item_name .. " x" .. count)
        end
    end
    if stash_items then
        for item_name, count in pairs(stash_items.last_lost_item_list) do
            msg = msg .. "- " .. item_name .. " x" .. count .. " stash_id " .. stash_id .. " \\n"
            -- print_dbg("Lost item: " .. item_name .. " x" .. count)
        end
    end
    return msg
end

local function send_items_report_news_msg(list_lost, stash_id)
    local items_recount = create_report_msg_string(list_lost, stash_id)
    local msg = list_lost and "You lost or got steal:" or
                    "You woke up and did a quick item recount, looks like this is missing:"
    db.actor:give_game_news("Item recount", tostring(msg .. " \\n" .. items_recount), "ui_inGame2_neutral_2_mask", 0,
        20000)
end

local function isFoodKind(item)
    return (ini_sys:r_string_ex(item:section(), "kind") == "i_food")
end

local function isMedicalKind(item)
    return (ini_sys:r_string_ex(item:section(), "kind") == "i_medical")
end
-- End of Utils

function load_settings()
    max_money_percentage = Dude_where_is_my_gear_mcm.get_config("max_money_percentage")
    max_money_to_drop_percentage = Dude_where_is_my_gear_mcm.get_config("max_money_to_drop_percentage")
    max_condition_lose = Dude_where_is_my_gear_mcm.get_config("max_condition_lose")
    min_condition_lose = Dude_where_is_my_gear_mcm.get_config("min_condition_lose")
    enable_time_forward = Dude_where_is_my_gear_mcm.get_config("enable_time_forward")
    keep_equipped_guns_ammo_chance = Dude_where_is_my_gear_mcm.get_config("keep_equipped_guns_ammo_chance")
    lose_item_condition = Dude_where_is_my_gear_mcm.get_config("lose_item_condition")
    keep_equipped_guns_chance = Dude_where_is_my_gear_mcm.get_config("keep_equipped_guns_chance")
    keep_equipped_outfit_chance = Dude_where_is_my_gear_mcm.get_config("keep_equipped_outfit_chance")
    full_heal_chance = Dude_where_is_my_gear_mcm.get_config("full_heal_chance")
    full_satiety_chance = Dude_where_is_my_gear_mcm.get_config("full_satiety_chance")
    meal_chance = Dude_where_is_my_gear_mcm.get_config("meal_chance")
    chance_of_losing_items = Dude_where_is_my_gear_mcm.get_config("chance_of_losing_items")
    campfire_save = Dude_where_is_my_gear_mcm.get_config("campfire_save")
    always_wake_up_daytime = Dude_where_is_my_gear_mcm.get_config("always_wake_up_daytime")
    remove_previous_stash = Dude_where_is_my_gear_mcm.get_config("remove_previous_stash")
    use_kill_type_mod = Dude_where_is_my_gear_mcm.get_config("use_kill_type_mod")
    use_rank_mod = Dude_where_is_my_gear_mcm.get_config("use_rank_mod")
end

function on_game_start()
    RegisterScriptCallback("on_option_change", load_settings)
    RegisterScriptCallback("on_game_load", load_settings)
    local ini_stash = ini_file("items\\settings\\backpack_stash.ltx")
    keep_items = utils_data.collect_section(ini_stash, "actor_backpack_keep_items", true)
    RegisterScriptCallback("actor_on_before_death", actor_on_before_death)
    RegisterScriptCallback("actor_on_sleep", actor_on_sleep)
    RegisterScriptCallback("save_state", save_state)
    RegisterScriptCallback("load_state", load_state)
    RegisterScriptCallback("actor_on_stash_create", actor_on_stash_create)
    RegisterScriptCallback("actor_on_stash_remove", actor_on_stash_remove)
    RegisterScriptCallback("on_game_load", on_game_load)
    RegisterScriptCallback("actor_on_before_hit", actor_on_before_hit)
    RegisterScriptCallback("on_before_save_input", on_before_save_input)
    RegisterScriptCallback("on_key_press", on_key_press)
    options_vol = ui_options.get("sound/general/master_volume")
end

function on_game_load()
    UnregisterScriptCallback("actor_on_before_death", actor_on_before_death)
    RegisterScriptCallback("actor_on_before_death", actor_on_before_death)
    exec_console_cmd("snd_volume_eff " .. options_vol)
    actor_rep = utils_obj.get_reputation_name(db.actor:character_reputation())
    actor_rank = ranks.get_obj_rank_name(db.actor)
    -- Make sure older versions are updated:
    local sleep = alife_storage_manager.get_state().dude_where_is_my_gear or sleep
    if not sleep.last_dropped_item_list then
        sleep.last_dropped_item_list = {}
        sleep.last_lost_item_list = {}
    end
    alife_storage_manager.get_state().dude_where_is_my_gear = sleep
end

function print_dbg(text, ...)
    if true then
        printf("RAX: | %s |  " .. text, time_global(), ...)
    end
end

function actor_on_before_hit(shit, bone_id, flag)
    local current_time = time_global()
    local sleep = alife_storage_manager.get_state().dude_where_is_my_gear or sleep
    check_attack_history_expiration()
    add_hit_record(shit.type)
    if sleep and sleep.last_death_time then
        local invulnerable_time = sleep.last_death_time + 65000
        if invulnerable_time < current_time then
            return
        end
        if invulnerable_time > current_time then
            if shit.type == 3 then
                shit.power = 0
                db.actor.radiation = 0
            else
                shit.power = 0
                db.actor.health = global_healing
            end

        end
    end
end

local direction_keys = {
    [key_bindings.kFWD] = true,
    [key_bindings.kBACK] = true,
    [key_bindings.kL_STRAFE] = true,
    [key_bindings.kR_STRAFE] = true,
    [key_bindings.kCROUCH] = true,
    [key_bindings.kACCEL] = true,
    [key_bindings.kWPN_FIRE] = true,
    [key_bindings.kWPN_ZOOM] = true,
    [key_bindings.kL_LOOKOUT] = true,
    [key_bindings.kR_LOOKOUT] = true,
    [key_bindings.kJUMP] = true,
    [7] = true
}

function on_key_press(dik)
    local bind = dik_to_bind(dik)
    if direction_keys[bind] and sleep and sleep.last_death_time ~= 0 then
        sleep.last_death_time = 0
    end
end

function actor_on_before_death(who, flags)
    local current_time = time_global()
    if last_death_time < current_time then
        print_dbg("set_last_death_time %s")
        last_death_time = current_time + 10000
        respawn_done = false
        sleep.last_death_time = last_death_time
        alife_storage_manager.get_state().dude_where_is_my_gear = sleep
    end
    if last_death_time > current_time and not respawn_done then
        actor_rep = utils_obj.get_reputation_name(db.actor:character_reputation())
        actor_rank = ranks.get_obj_rank_name(db.actor)
        local final_cause_of_death = determine_main_cause_of_death(death_last_attacks)
        respawn_done = true
        db.actor:set_health_ex(1)
        if not currently_respawning then
            print_dbg("currently_respawning if NOT %s", currently_respawning)
            drop_stash(final_cause_of_death, actor_rank, actor_rep)
            currently_respawning = 1
        end

        if currently_respawning == 1 then
            print_dbg("currently_respawning if 1 %s", currently_respawning)
            options_vol = ui_options.get("sound/general/master_volume")
            level.disable_input()
            get_console():execute("hud_draw off")
            -- Temp remove to avoid crashes for non GAMMA players
            -- level.add_pp_effector("concussion_bhs.ppe", 99123, false)
            exec_console_cmd("snd_volume_eff " .. 0.01)

            level.add_cam_effector("camera_effects\\surge_02.anm", 444, false,
                "dude_where_is_my_gear.on_tutor_gameover_respawn")
            level.add_pp_effector("actor_death.ppe", 445, false)
            level.add_pp_effector("rcom_actor_death_quick.ppe", 446, false)
            local function draw_hud()
                level.enable_input()
                get_console():execute("hud_draw on")
                return true
            end
            CreateTimeEvent("respawn_mode_draw_hud", "draw_hud", 2, draw_hud)

            currently_respawning = 2
        end
        -- Amazing healing and satiety calculation from Curse of Inmmortality mod by Yonte and  Mr_Gepardas	
        --- Forward Time ---
        local forwardTimeMinHours = 8
        local forwardTimeMaxHours = 72
        local p = {}
        p[1] = math.random(forwardTimeMinHours, forwardTimeMaxHours)
        p[2] = math.random(0, 59)
        if always_wake_up_daytime then
            local max_wake_hour = 16
            local min_wake_hour = 6
            local cur_hour = level.get_time_hours()
            local wake_hour = cur_hour + p[1]
            local final_day_hour = ((wake_hour / 24) % 1) * 24
            if final_day_hour < 6 then
                p[1] = p[1] + (6 - final_day_hour)
            elseif final_day_hour > 16 then
                p[1] = p[1] - (final_day_hour - 16)
            end
        end
        -- Heal player--
        local healing = 0.25
        local satiety = 1
        local mealVal = 0.1
        local satiety_minus_per_hour = 0.02
        local power = math.random(3, 10) / 10
        if math.random(1, 100) <= full_heal_chance then
            healing = 1
        else
            -- Heal player depending on how much time was spent being down/knocked out
            healing = healing + (0.007 * p[1]) + (0.00011 * p[2])
        end
        if healing > 1 then
            healing = 1
        end
        -- Satiety calculation--
        if math.random(1, 100) <= full_satiety_chance then
            satiety = 1
        else
            -- Logic: actor can get a meal every 6 hours 
            if satiety_minus_per_hour * p[1] >= satiety then
                satiety = 0.2
            else
                satiety = satiety - (satiety_minus_per_hour * p[1])
            end
            local additionalFood = math.random(1, 80) / 1000
            local totalFood = p[1] / 6
            local foodWithChance = totalFood * (meal_chance / 100)
            satiety = satiety + (foodWithChance * mealVal) + additionalFood
            if satiety > 1 then
                satiety = 1
            elseif satiety < 0.2 then
                satiety = 0.2
            end
        end

        if currently_respawning == 2 then
            print_dbg("currently_respawning if 2 %s", currently_respawning)
            if enable_time_forward then
                xr_effects.forward_game_time(nil, nil, p)
                -- level.change_game_time(0, p[1], 0)
                local forward_text = tostring("You have been out of action for " .. p[1] .. " Hours and " .. p[2] ..
                                                  " Minutes")
                db.actor:give_game_news("Severe Injured", forward_text, "ui_inGame2_neutral_2_mask", 0, 20000)
            end
            currently_respawning = 3
        end

        if currently_respawning == 3 then
            currently_respawning = 4
            bind_stalker_ext.respawn_new_health = healing
            global_healing = healing
            global_satiety = satiety
            global_power = power
            db.actor:give_game_news("Recovery",
                tostring("You got took out by " .. final_cause_of_death .. " and now feel better " ..
                             math.floor(global_healing * 100 + 0.5) .. "% of health " ..
                             math.floor(global_satiety * 100 + 0.5) .. "% Satiety"), "ui_inGame2_neutral_2_mask", 0,
                20000)
        end

        if currently_respawning == 4 then
            currently_respawning = nil
        end

        -- get_console():execute("hud_draw on")
        -- level.enable_input()
    end
    print_dbg("healing %s", global_healing)
    print_dbg("power %s", global_power)
    print_dbg("satiety %s", global_satiety)
    db.actor.health = global_healing
    -- db.actor:set_health_ex(global_healing)
    db.actor.bleeding = 1
    db.actor.psy_health = 1
    db.actor.radiation = 0
    db.actor.satiety = global_satiety
    db.actor.power = global_power
    arszi_psy.set_psy_health(1)
    flags.ret_value = false
end

keep_items = nil

function drop_stash(final_cause_of_death, actor_rank, actor_rep)
    sleep.dead = true
    local actor = db.actor
    local se_obj = alife_create("inv_backpack", actor:position(), actor:level_vertex_id(), actor:game_vertex_id())
    if not sleep.dropped_stashes then
        sleep.dropped_stashes = {}
    elseif remove_previous_stash and #sleep.dropped_stashes > 0 then
        for i, stash_id in ipairs(sleep.dropped_stashes) do
            if stash_id then
                sleep.dropped_stashes[stash_id] = nil
                alife_release_id(stash_id)
            end
        end
    end
    local ignore_items = {
        ["itm_pda_common"] = true,
        ["device_pda_1"] = true,
        ["device_pda_2"] = true,
        ["device_pda_3"] = true,
        ["detector_simple"] = true,
        ["itm_actor_backpack"] = true
    }
    if (se_obj) then
        local txt = strformat(game.translate_string("st_itm_stash_of_character"), db.actor:character_name())
        level.map_add_object_spot_ser(se_obj.id, "treasure", txt)
        actor_menu.set_msg(1, game.translate_string("st_stash_created"), 4)

        local m_data = alife_storage_manager.get_state()
        if not (m_data.player_created_stashes) then
            m_data.player_created_stashes = {}
        end

        m_data.player_created_stashes[se_obj.id] = itm_backpack

        local by_gun_mod = 1
        local condition_mod = 1
        local by_beast_mod = 1
        local general_mod = 1
        if (use_rank_mod) then
            general_mod = define_rank_modifier(actor_rank)
        end
        if (use_kill_type_mod and final_cause_of_death == "gun") then
            by_gun_mod = 0.5
        end
        if (use_kill_type_mod and final_cause_of_death == "elemental") then
            condition_mod = 0.75
        end
        if (use_kill_type_mod and final_cause_of_death == "beast") then
            by_beast_mod = 0.5
        end

        -- Lose money
        local denominations = {{
            name = "money_1000",
            value = 1000
        }, {
            name = "money_100",
            value = 100
        }, {
            name = "money_10",
            value = 10
        }}
        local current_money = actor:money()
        -- /by_gun_mod if killed by gun duplicates max amount of money to lost.
        -- /by_beast_mod if killed by beast reduce by half max amount of money to lost.
        local money_to_lose = math.random(0, math.floor(current_money * max_money_percentage / by_gun_mod)) *
                                  by_beast_mod
        db.actor:give_money(-money_to_lose)

        -- Drop money into dropped stash. by_gun_mod reduces by half amount of money to get back on stash.
        local money_left = math.random(math.floor(money_to_lose * 0.15),
            math.floor(money_to_lose * max_money_to_drop_percentage)) * by_gun_mod

        for _, denom in ipairs(denominations) do
            local num_items_to_create = math.floor(money_left / denom.value)
            money_left = money_left % denom.value
            for i = 1, num_items_to_create do
                alife_create_item(denom.name, se_obj)
            end
        end

        print_dbg("Total money to lose: " .. money_to_lose)
        local function transfer_items(id)
            local obj = level.object_by_id(id)
            if (obj) then
                local function itr_inv(temp, item)
                    print_dbg("item: %s", item:section())
                    local section = item:section()
                    local item_id = item:id()

                    if ignore_items[section] then
                        return
                    end

                    if item_id == b_id or keep_items[section] ~= nil then
                        return
                    end

                    if ini_sys:r_bool_ex(section, "quest_item", false) then
                        return
                    end

                    local is_keeping_item = math.random(1, 100) >= chance_of_losing_items / general_mod
                    -- if item is in slot get current item:condition() and reduce it randomly between 2% and 20%
                    if lose_item_condition then
                        local condition = item:condition()
                        -- if killed by elemental damage increase condition lose of equipped items
                        local condition_reduction =
                            (math.random(min_condition_lose, max_condition_lose) / condition_mod / general_mod) / 100
                        condition = condition - condition_reduction
                        if (condition < 0) then
                            condition = 0
                        end
                        item:set_condition(condition)
                    end
                    if IsPistol(item) or IsMelee(item) then
                        -- Ignore pistols type and melee until "experienced" rank
                        if actor_rank ~= "novice" and actor_rank ~= "trainee" then
                            print_dbg("IsPistol or IsMelee")
                            if item_backpack.is_in_slot(item) == true and math.random(1, 100) <=
                                (keep_equipped_guns_chance * general_mod) then
                                print_dbg("keep_equipped_guns_chance")
                            elseif math.random(1, 100) <=
                                (chance_of_losing_items / by_gun_mod / general_mod * by_beast_mod * condition_mod) then
                                alife_release(item)
                                add_to_dropped_item_list(item, 'l', se_obj.id)
                            else
                                db.actor:transfer_item(item, obj)
                                add_to_dropped_item_list(item, 'd', se_obj.id)
                            end
                    elseif IsWeapon(item) then
                        print_dbg("IsWeapon")
                        -- If killed by gun chance of losing equipped weapon is increased by by_gun_mod
                        if item_backpack.is_in_slot(item) == true and math.random(1, 100) <= (keep_equipped_guns_chance * general_mod) then
                            print_dbg("keep_equipped_guns_chance")
                        elseif math.random(1, 100) <=
                            (chance_of_losing_items / by_gun_mod / general_mod * by_beast_mod * condition_mod) then
                            alife_release(item)
                            add_to_dropped_item_list(item, 'l', se_obj.id)
                        else
                            db.actor:transfer_item(item, obj)
                            add_to_dropped_item_list(item, 'd', se_obj.id)
                        end
                    elseif IsOutfit(item) or IsHeadgear(item) then
                        print_dbg("IsOutfit")
                        -- If killed by gun chance of losing equipped outfit is increased by by_gun_mod
                        if item_backpack.is_in_slot(item) == true and math.random(1, 100) <= (keep_equipped_outfit_chance * general_mod) then
                            print_dbg("keep_equipped_outfit_chance")
                        elseif math.random(1, 100) <=
                            (chance_of_losing_items / by_gun_mod / general_mod * by_beast_mod * condition_mod) then
                            alife_release(item)
                            add_to_dropped_item_list(item, 'l', se_obj.id)
                        else
                            db.actor:transfer_item(item, obj)
                            add_to_dropped_item_list(item, 'd', se_obj.id)
                        end
                    elseif item_backpack.is_ammo_for_wpn(item:section()) == true then
                        if math.random(1, 100) >= (keep_equipped_guns_ammo_chance / by_gun_mod * general_mod) then
                            db.actor:transfer_item(item, obj)
                            add_to_dropped_item_list(item, 'd', se_obj.id)
                        end
                    elseif string.match(item:section(), "^mag_") then
                        -- Partial compatibility with MagsRedux (always keep all the mags)
                    elseif isMedicalKind(item) then
                        -- If killed by gun chance of losing medical items is increased by by_gun_mod
                        if math.random(1, 100) <=
                            (chance_of_losing_items / by_gun_mod / general_mod * by_beast_mod * condition_mod) then
                            alife_release(item)
                            add_to_dropped_item_list(item, 'l', se_obj.id)
                        else
                            db.actor:transfer_item(item, obj)
                            add_to_dropped_item_list(item, 'd', se_obj.id)
                        end
                    elseif isFoodKind(item) then
                        -- If killed by beast chance of losing food is increased by by_beast_mod
                        if math.random(1, 100) <=
                            (chance_of_losing_items / by_beast_mod / general_mod * by_gun_mod * condition_mod) then
                            alife_release(item)
                            add_to_dropped_item_list(item, 'l', se_obj.id)
                        else
                            db.actor:transfer_item(item, obj)
                            add_to_dropped_item_list(item, 'd', se_obj.id)
                        end
                    elseif not is_keeping_item then
                        alife_release(item)
                        add_to_dropped_item_list(item, 'l', se_obj.id)
                    else
                        db.actor:transfer_item(item, obj)
                        add_to_dropped_item_list(item, 'd', se_obj.id)
                    end
                end
                -- table.insert(sleep.dropped_stashes, {
                --     s_id = se_obj.id,
                --     last_dropped_item_list = sleep.last_dropped_item_list,
                --     last_lost_item_list = sleep.last_lost_item_list
                -- })
                print_dbg("Dropped stash %s", se_obj.id)
                db.actor:iterate_inventory(itr_inv)
                send_items_report_news_msg(false, se_obj.id)
                return true
            end
            return false
        end
        alife_storage_manager.get_state().dude_where_is_my_gear = sleep
        CreateTimeEvent("RAX SleepSpawn", "actor_backpack", 0, transfer_items, se_obj.id)
    end
end

function forward_time(p)
    if enable_time_forward then
        xr_effects.forward_game_time(nil, nil, p)
        local forward_text = tostring("You have been out of action for " .. p[1] .. " Hours and " .. p[2] .. " Minutes")
        db.actor:give_game_news("Severe Injured", forward_text, "ui_inGame2_neutral_2_mask", 0, 20000)
    end
end

function save_position(stash_data)
    local sleep = alife_storage_manager.get_state().dude_where_is_my_gear or sleep
    pos = db.actor:position()
    print_dbg("SAVE POSITION %s| %s %s %s |", level.name(), pos.x, pos.y, pos.z)
    if stash_data then
        sleep.stash_save = {}
        sleep.stash_created = true
        sleep.stash_save.level = level.name()
        sleep.stash_save.posX = pos.x
        sleep.stash_save.posY = pos.y
        sleep.stash_save.posZ = pos.z
        sleep.stash_save.position = vector():set(sleep.stash_save.posX or 0, sleep.stash_save.posY or 0,
            sleep.stash_save.posZ or 0)
        sleep.stash_save.level_vert = db.actor:level_vertex_id()
        sleep.stash_save.game_vert = db.actor:game_vertex_id()
        sleep.stash_save.stash_id = stash_data.stash_id
        sleep.type = "stash"
        level.map_add_object_spot_ser(stash_data.stash_id, "ui_pda2_actor_sleep_location", "Respawn")
    else
        sleep.level = level.name()
        sleep.posX = pos.x
        sleep.posY = pos.y
        sleep.posZ = pos.z
        sleep.position = vector():set(sleep.posX or 0, sleep.posY or 0, sleep.posZ or 0)
        sleep.level_vert = db.actor:level_vertex_id()
        sleep.game_vert = db.actor:game_vertex_id()
        sleep.sleep_created = true
        sleep.type = "sleep"
    end
    alife_storage_manager.get_state().dude_where_is_my_gear = sleep
end

function actor_on_sleep()
    local sleep = alife_storage_manager.get_state().dude_where_is_my_gear or sleep
    if not sleep.stash_created or sleep.stash_created == false then
        print_dbg("SET POSITION on SLEEP")
        sleep.sleep_created = true;
        save_position()
    end
end

function actor_on_stash_create(stash_data)
    local sleep = alife_storage_manager.get_state().dude_where_is_my_gear or sleep
    sleep.stash_created = true;
    save_position(stash_data)
end

function actor_on_stash_remove(stash_data)
    local sleep = alife_storage_manager.get_state().dude_where_is_my_gear or sleep
    if sleep.stash_save and (stash_data.stash_id == sleep.stash_save.stash_id) then
        sleep.stash_created = false;
        sleep.stash_save = nil
        sleep.type = "sleep"
    end
    if sleep.dropped_stashes and sleep.dropped_stashes[stash_data.stash_id] then
        send_items_report_news_msg(true, stash_data.stash_id)
        sleep.dropped_stashes[stash_data.stash_id] = nil
    end
    alife_storage_manager.get_state().dude_where_is_my_gear = sleep
end

-- NOT WORKING, NEED TO FIGURE OUT ANOTHER APPROACH
function actor_on_save()
    -- print_dbg("ON SAVE | %s %s", sleep.stash_created, sleep.sleep_created)
    -- if sleep.stash_created == false and sleep.sleep_created == false then
    --     print_dbg("SET POSITION on SAVE")
    --     save_position()
    -- end
end

function on_before_save_input(flags, typ_, text)
    if not campfire_save then
        local error_message = strformat("Campfire save not allowed.", text)
        -- always prevent saving.
        exec_console_cmd("main_menu off")
        flags.ret = true
        actor_menu.set_msg(1, error_message, 4)

    end
end
function save_state(mdata)
    alife_storage_manager.get_state().dude_where_is_my_gear = sleep

end

function load_state(mdata)
    sleep = alife_storage_manager.get_state().dude_where_is_my_gear or sleep
    sleep.position = vector():set(sleep.posX or 0, sleep.posY or 0, sleep.posZ or 0)
    -- sleep.position = vector():set(sleep.stash_save.posX or 0, sleep.stash_save.posY or 0, sleep.stash_save.posZ or 0)
end

function on_tutor_gameover_respawn()
    local sleep = alife_storage_manager.get_state().dude_where_is_my_gear or sleep
    currently_respawning = nil
    -- Test fix for bleeding after respawning
    db.actor.bleeding = 1
    if sleep and (sleep.posX and sleep.level and (sleep.level ~= level.name())) or
        (sleep.stash_save and sleep.stash_save.posX and sleep.stash_save.level and
            (sleep.stash_save.level ~= level.name())) then
        print_dbg("SAME LEVEL TELEPORT")
        if sleep.stash_created then
            local player_vector_x = sleep.stash_save.posX
            local player_vector_y = sleep.stash_save.posY
            local player_vector_z = sleep.stash_save.posZ
            ChangeLevel(vector():set(player_vector_x, player_vector_y, player_vector_z), sleep.stash_save.level_vert,
                sleep.stash_save.game_vert, VEC_ZERO, true)
        else
            local player_vector_x = sleep.posX
            local player_vector_y = sleep.posY
            local player_vector_z = sleep.posZ
            ChangeLevel(vector():set(player_vector_x, player_vector_y, player_vector_z), sleep.level_vert,
                sleep.game_vert, VEC_ZERO, true)
        end
    elseif sleep and (sleep.posX or sleep.stash_save and sleep.stash_save.posX) then
        local player_lvid = db.actor:level_vertex_id()
        local player_gvid = db.actor:game_vertex_id()
        print_dbg("DIFFERENT LEVEL TELEPORT")
        if sleep.stash_created then
            local player_vector_x = sleep.stash_save.posX
            local player_vector_y = sleep.stash_save.posY
            local player_vector_z = sleep.stash_save.posZ
            xr_effects.change_level_now(vector():set(player_vector_x, player_vector_y, player_vector_z), player_lvid,
                player_gvid, VEC_ZERO, true)
        else
            local player_vector_x = sleep.posX
            local player_vector_y = sleep.posY
            local player_vector_z = sleep.posZ
            xr_effects.change_level_now(vector():set(player_vector_x, player_vector_y, player_vector_z), player_lvid,
                player_gvid, VEC_ZERO, true)
        end
    elseif db.actor:character_community() == "actor_stalker" then -- if loner >>
        print_dbg("LONER TELEPORT")
        xr_effects.change_level_now(vector():set(-246.0744, -24.8076, -136.0753), 14372, 372, VEC_ZERO, true) -- sidorovich's bunker

    elseif db.actor:character_community() == "actor_army" then -- if military >>
        xr_effects.change_level_now(vector():set(-123.26, -28.4, -379.96), 133511, 450, VEC_ZERO, true) -- southern checkpoint

    elseif db.actor:character_community() == "actor_bandit" then -- if bandit >>
        xr_effects.change_level_now(vector():set(20.72, 7.85, -42.93), 189149, 1515, VEC_ZERO, true) -- northern factory

    elseif db.actor:character_community() == "actor_csky" then -- if clear sky >>
        xr_effects.change_level_now(vector():set(-140.56, 1.5, -317.99), 75660, 136, VEC_ZERO, true) -- hidden base

    elseif db.actor:character_community() == "actor_dolg" then -- if duty >>
        xr_effects.change_level_now(vector():set(229.09, -5.449, 128.31), 59298, 1704, VEC_ZERO, true) -- duty headquarter

    elseif db.actor:character_community() == "actor_ecolog" then -- if ecologist >>
        xr_effects.change_level_now(vector():set(28.96, -10.05, -280.12), 78646, 2281, VEC_ZERO, true) -- sakharovs bunker

    elseif db.actor:character_community() == "actor_freedom" then -- if freedom >>
        xr_effects.change_level_now(vector():set(-18.02, -2.46, -31.74), 274912, 2092, VEC_ZERO, true) -- military base

    elseif db.actor:character_community() == "actor_killer" then -- if mercenary >>
        xr_effects.change_level_now(vector():set(-56.6, 8.92, 37.57), 96425, 2367, VEC_ZERO, true) -- sports center

    elseif db.actor:character_community() == "actor_monolith" then -- if monolith >>
        xr_effects.change_level_now(vector():set(-3.59, -3.50, 189.80), 98087, 3069, VEC_ZERO, true) -- cultural center

    elseif db.actor:character_community() == "actor_monolith" then -- if sin >>
        xr_effects.change_level_now(vector():set(-152.36056518555, 2.2933793067932, -26.791021347046), 5570, 2772,
            VEC_ZERO, true) -- red forest old mine

    elseif db.actor:character_community() == "actor_monolith" then -- if renegade >>
        xr_effects.change_level_now(vector():set(-179.78, 4.13, 417.23), 52100, 80, VEC_ZERO, true) -- tuzla outpost

    else -- if unisg/ other >>
        xr_effects.change_level_now(vector():set(136.32, 28.9, 240.395), 348892, 4920, VEC_ZERO, true) -- hideout in outskirts
    end
end
